#' Annotates MS2 data with adduct information
#'
#' This function allows you to annotate MS2 parent ions with addcut information and calculate the neutral mass of the ions.
#' This function also generates the general parameters for the downstream search engines.
#'
#'
#' @param inputMS2List A MS2 list generated by \code{\link{map_features}}
#' @param input_camera A CAMERA object (results of preprocessing using CAMERA)
#' @param precursorppm Precursor ppm mass deviation for database search
#' @param fragmentppm Fragment (MS2) ppm mass deviation for database search
#' @param fragmentabs Fragment (MS2) absolute mass deviation for database search
#' @param minPrecursorMass Minimum precursor mass to consider. Default 0
#' @param maxPrecursorMass Maximum precursor mass to consider NA=all. Default NA
#' @param minPeaks The minimum number of MS2 peaks that should be present for an ion to be consider
#' @param maxSpectra The maximum number of ions to write (mostly used for testing)
#' @param mode Ionization mode. Either pos or neg corresponding to positive and negative, respectively
#' @param adductRules What types of adducts to consider. Either primary or extended (see details). Default primary
#' @param outputDir Output directory to write individual ions
#' @param searchMultipleChargeAdducts Set to TRUE if you want to consider the selected adducts (primary or extended) for unmapped ions or ions without adduct information from CAMERA. Default TRUE
#' @param includeMapped Set to TRUE if you want to include mapped ions. Default TRUE
#' @param includeUnmapped Set to TRUE if you want to include unmapped ions. Default FALSE
#' @param verbose Show information about different stages of the processes. Default FALSE
#' @export
#' @examples
#'
#' library(CAMERA)
#' library(metaboraid)
#' # Read MS1 and MS2 files
#' ms1_files<-system.file("ms1data",c("X1_Rep1.mzML","X2_Rep1.mzML"),package = "metaboraid")
#' ms2_files<-system.file("ms2data",c("sample1.mzML","sample2.mzML"),package = "metaboraid")
#'
#' # mass trace detection
#' xs <- xcmsSet(ms1_files,method="centWave",ppm=30,peakwidth=c(5,10))
#'
#' # mass trace matching
#' xsg <- group(xs)
#'
#' # convert to CAMERA
#' xsa <- xsAnnotate(xsg)
#'
#' # Group mass traces
#' anF <- groupFWHM(xsa, perfwhm = 0.6)
#'
#' # Detect isotopes
#' anI <- findIsotopes(anF, mzabs = 0.01)
#'
#' # Group using correlation
#' anIC <- groupCorr(anI, cor_eic_th = 0.75)
#'
#' # Find adducts
#' anFA <- findAdducts(anIC, polarity="positive")
#'
#' # map features and MS2s
#' mapped_features<-map_features(inputMS2s = ms2_files,input_camera = anFA,ppm = 10,rt = 10)
#'
#' # Map adducts
#' mapped_adducts<-map_adducts(inputMS2List=mapped_features,input_camera=anFA,
#'                             precursorppm=10,
#'                             fragmentppm=20,fragmentabs=0.01,minPrecursorMass=NA,maxPrecursorMass=NA,
#'                             minPeaks=10,maxSpectra=10,mode="pos",adductRules="primary",
#'                             outputDir="general_parameters_4",searchMultipleChargeAdducts=T,
#'                             includeMapped=T,includeUnmapped=F,verbose=T)
#' @return
#' A zip file containing the parameters needed for all the search engines. Each file inside the zip file includes all the set parameters and MS2 ions and estimated neutral mass and adduct information
#'
#' @details
#' MetaboRAID attempts to estimate the neutral mass of the molecules to decrease the search space of search engines.
#' The approach starts with mapping the MS2 parent mz and RT to the CAMERA features. We then search whether that specific feature has been annotated with adducts or isoptopes.
#' If so, the neutral mass will be estimated based on the adduct information.
#' However if there is no adduct information in CAMERA results for a particular ion, if searchMultipleChargeAdducts is set to TRUE, we generate all the selected ions based on adductRules:
#' primary: [M-H]-, [M-2H+Na]-, [M-2H+K]-, [M+Cl]-, [M+H]+, [M+Na]+, [M+K]+, [M+NH4]+
#' extended: We genrated up to three changes state for adduct information for each of them
#'
#' @import reticulate
#' @import zip
#' @import parallel
#' @import future
#' @import progressr
#' @import future.apply
#'


map_adducts<-function(inputMS2List=NA,input_camera=NA,
                      precursorppm=10,
                      fragmentppm=20,fragmentabs=0.01,minPrecursorMass=NA,maxPrecursorMass=NA,
                      minPeaks=0,maxSpectra=NA,mode="pos",adductRules="primary",
                      outputDir="general_parameters",searchMultipleChargeAdducts=T,
                      includeMapped=T,includeUnmapped=F,verbose=T)
{


  if(any(is.na(precursorppm)) | any(is.null(precursorppm)) | !any(is.numeric(precursorppm)))
  {
    stop("No valid precursorppm input has been provided! It has to be a numberic higher than zero!")
  }

  if(any(is.na(fragmentppm)) | any(is.null(fragmentppm)) | !any(is.numeric(fragmentppm)))
  {
    stop("No valid fragmentppm input has been provided! It has to be a numberic higher than zero!")
  }

  if(any(is.na(fragmentabs)) | any(is.null(fragmentabs)) | !any(is.numeric(fragmentabs)))
  {
    stop("No valid fragmentabs input has been provided! It has to be a numberic higher than zero!")
  }

  if(any(is.na(minPeaks)) | any(is.null(minPeaks)) | !any(is.numeric(minPeaks)))
  {
    stop("No valid minPeaks input has been provided! It has to be a numberic higher than or equal to zero!")
  }


  if(any(is.na(mode)) | any(is.null(mode)))
  {
    stop("No valid mode input has been provided! It has to be either 'pos' or 'neg'")
  }

  if(any(is.na(adductRules)) | any(is.null(adductRules)))
  {
    stop("No valid adductRules input has been provided! It has to be either 'primary' or 'extended'")
  }

  if(!mode%in%c("pos","neg"))
  {
    stop("No valid mode input has been provided! It has to be either 'pos' or 'neg'")
  }

  if(!adductRules%in%c("primary","extended"))
  {
    stop("No valid mode input has been provided! It has to be either 'pos' or 'neg'")
  }

  if(verbose)cat("\nCreating output directory: ",outputDir,"\n")
  dir.create(outputDir, showWarnings = FALSE)

  database<-"[database]"
  settingsObject<-list()
  settingsObject[["DatabaseSearchRelativeMassDeviation"]]<-precursorppm
  settingsObject[["FragmentPeakMatchAbsoluteMassDeviation"]]<-fragmentabs
  settingsObject[["FragmentPeakMatchRelativeMassDeviation"]]<-fragmentppm
  settingsObject[["MetFragDatabaseType"]]<-database
  settingsObject[["MetFragScoreTypes"]]<-"FragmenterScore"

  if(verbose)cat("\nEstimating adducts ...","\n")
  toMetfragCommand(mappedMS2 = inputMS2List$mapped,unmappedMS2 = inputMS2List$unmapped,
                   cameraObject = input_camera,searchMultipleChargeAdducts = T,includeUnmapped = F,
                   includeMapped = T,settingsObject = settingsObject,preprocess = F,
                   savePath=outputDir, minPeaks=minPeaks,
                   maxSpectra=maxSpectra, maxPrecursorMass = maxPrecursorMass,
                   minPrecursorMass = minPrecursorMass, mode = mode, primary = (adductRules == "primary"))
  if(verbose)cat("\nAdduct estimating has been done ...","\n")
  if(verbose)cat("\nCompressing the results ...","\n")
  
  ## Saman: correcting precursor ion type from [...]n+ into [...]+ 
  fl <- list.files(path = outputDir,pattern = "*.txt", full.names = TRUE, recursive = FALSE)  
  lapply(fl, function(f)  {
    tst <- readLines(f)
    #tst
    #str_view_all(tst, "]\\d*\\+")
    tst2 <- gsub("](\\d*|\\w*|\\W*)\\+", "]+", tst)
    writeLines(tst2, as.character(f))
  }
  )

  zip::zip(zipfile="parameter_files.zip",files=list.files(path = outputDir,pattern="txt",full.names = T),include_directories = F)
  if(verbose)cat("\nCompressing the results has been doen ...","\n")
  if(verbose)cat("\nThe parameter file is: ",list.files(pattern = "^parameter_files.zip",full.names = T),"\n")
  return(list.files(pattern = "^parameter_files.zip",full.names = T))  # to avoid printing test_parameter_files.zip
}
