#' Perform identification using Chemdistiller
#'
#' This function allows you to perform identification using Chemdistiller
#' Please note that you need to have Chemdistiller, e.g using \code{\link{install_tools}} only on Linux or IOS.
#' For Windows see the details
#'
#' We install Chemdistiller in metaboraid_package environment.
#'
#'
#'
#' @param parameter_zip_files A zip file containing MS2 parameter generated by \code{\link{map_adducts}}
#' @param database Name of the database to use: This has to be according to the database_file and the folder. See details.
#' @param database_file Absolute path to a text file containing the paths to the folders containing the databases.
#' @param svm_model_path Absolute path to a folder containing uncompressed model files.
#' @param max_number_of_compound Maximum number of compounds to report for each ion. Default 100
#' @param ncores Number of cores to use for parallel processing. Default 1
#' @param progress_bar Whether to show progress bar or not. Default FALSE
#' @param verbose Show information about different stages of the processes. Default FALSE
#' @param conda Conda binary to use. Default auto
#' @param env conda environment used to run the process. Default metaboraid_package
#' @param results_folder a path to a folder where results for EACH ion will be returned
#' @param chech_file_interval not used
#' @param total_check_time not used
#' @param timeout The maximum number of seconds to wait for a single out to give a result. Default 600
#' @export
#' @details
#' Fixing database:
#' Care must be taken for preparing data for Chemdistiller. In order to get this function to work. You need to first prepare the datasets:
#' 1. Create a folder where you want to place the datasets (for examples "DBs")
#' 2. Visit \url{https://www.mediafire.com/folder/v5l4380gqbvie/DBs} and download the datasets of interest (h5 files).
#' 3. Please the downloaded files in the folder you created in step 1. If you downloaded zip files, unzip the in the folder
#' 4. Find the absolute path to the folder. For example /home/youName/metabolomics/DBs
#' 5. create a text file somewhere on your system. For example /home/youName/metabolomics/mydatabases.txt
#' 6 Add the absolute path to the folder (step 4) and place in the text file.
#' 7. You can now set database_file to /home/youName/metabolomics/mydatabases.txt
#' 8. To set database parameter, look at the files you have downloaded. They start with the database name followed by underscore. So if you have downloaded "LipidMaps_[21_53_1214_01_2017].h5" you need to set database="LipidMaps" when running the function
#'
#' Fixing svm_model_path:
#' 1. Create a folder on your system for example "SVMs"
#' 2. Download ONE of the models from here: \url{https://www.mediafire.com/folder/v4lb8s2nns9c6/SVMs}
#' 3. Unzip the file in the folder you have created in step 1
#' 4. Find the abosolute path to the folder you have created in step 1 (e.g. /home/youName/metabolomics/SVMs)
#' 5. Set svm_model_path="/home/youName/metabolomics/SVMs" when running the function
#'
#' @examples
#'
#' library(CAMERA)
#' library(metaboraid)
#' # Read MS1 and MS2 files
#' ms1_files<-system.file("ms1data",c("X1_Rep1.mzML","X2_Rep1.mzML"),package = "metaboraid")
#' ms2_files<-system.file("ms2data",c("sample1.mzML","sample2.mzML"),package = "metaboraid")
#'
#' # mass trace detection
#' xs <- xcmsSet(ms1_files,method="centWave",ppm=30,peakwidth=c(5,10))
#'
#' # mass trace matching
#' xsg <- group(xs)
#'
#' # convert to CAMERA
#' xsa <- xsAnnotate(xsg)
#'
#' # Group mass traces
#' anF <- groupFWHM(xsa, perfwhm = 0.6)
#'
#' # Detect isotopes
#' anI <- findIsotopes(anF, mzabs = 0.01)
#'
#' # Group using correlation
#' anIC <- groupCorr(anI, cor_eic_th = 0.75)
#'
#' # Find adducts
#' anFA <- findAdducts(anIC, polarity="positive")
#'
#' # map features and MS2s
#' mapped_features<-map_features(inputMS2s = ms2_files,input_camera = anFA,ppm = 10,rt = 10)
#'
#' # Map adducts
#' mapped_adducts<-map_adducts(inputMS2List=mapped_features,input_camera=anFA,
#'                             precursorppm=10,
#'                             fragmentppm=20,fragmentabs=0.01,minPrecursorMass=NA,maxPrecursorMass=NA,
#'                             minPeaks=10,maxSpectra=10,mode="pos",adductRules="primary",
#'                             outputDir="general_parameters_4",searchMultipleChargeAdducts=T,
#'                             includeMapped=T,includeUnmapped=F,verbose=T)
#'
#' # Run the search
#'
#' run_chemdistiller(parameter_zip_files="parameter_files.zip",database="LipidMaps",
#' database_file="/home/youName/metabolomics/mydatabases.txt",
#' svm_model_path="/home/youName/metabolomics/SVMs/",
#' max_number_of_compound=10,ncores = 10)
#'
#' @return
#' A dataframe containing the identified ions. The dataframe contains search engine and database specific information but also tree important columns: parentMZ, parentRT, fileName which are used to trace the ions by the downstream processes.
#' @import reticulate
#' @import zip
#' @import parallel
#' @import future
#' @import progressr
#' @import future.apply
#' @import utils
#' @import plyr
#'



run_chemdistiller<-function(parameter_zip_files=NA,database=NA,database_file=NA,svm_model_path,max_number_of_compound=1,
                            ncores=1,progress_bar=T,verbose=F,conda = "auto",env="metaboraid_package",results_folder=NA,
                            chech_file_interval=2,total_check_time=20,timeout=600){
  if(verbose)cat("\nChecking software ...","\n")
  check_if_conda_is_installed(pkg = env,conda=conda)
  check_out<-suppressWarnings(check_if_software_exist("annotate_ch",conda=conda))
  if(length(check_out)==1 && check_out==1)
  {
    stop("We did not find annotate_ch! Please try installing the tools first!")
  }

  check_out<-suppressWarnings(check_if_software_exist("mgf_convert",conda=conda))
  if(length(check_out)==1 && check_out==1)
  {
    stop("We did not find mgf_convert! Please try installing the tools first!")
  }

  check_out<-suppressWarnings(check_if_software_exist("sirius",conda=conda))
  if(length(check_out)==1 && check_out==1)
  {
    stop("We did not find sirius! Please try installing the tools first!")
  }


  conda_path<-reticulate::conda_binary(conda)
  if(any(is.na(database)) | any(is.null(database)))
  {
    stop("The database must be defined according to Chemdistiller eg. ChEBI!")
  }
  database<-paste(database,collapse = ",")

  main_params<-c("run","-n",env)
  if(verbose)cat("\nChecking database ...","\n")
  if(is.na(database_file) | is.null(database_file))
  {
    stop("database_file must a valid path to a folder containing the databases!")
  }else if(!file.exists(database_file)){
    stop("database_file must a valid path to a folder containing the databases!")
  }

  if(is.na(svm_model_path) | is.null(svm_model_path))
  {
    stop("svm_model_path must a valid path to a folder containing the databases!")
  }else if(!file.exists(database_file)){
    stop("svm_model_path must a valid path to a folder containing the databases!")
  }

  if(is.na(parameter_zip_files) | is.null(parameter_zip_files))
  {
    stop("parameter_zip_files is missing!")
  }else{
    if(!file.exists(parameter_zip_files)){
      stop(sprintf("We could not find %s! Check parameter_zip_files!",parameter_zip_files))
    }
  }

  if(any(is.na(max_number_of_compound)) | any(is.null(max_number_of_compound)))
  {
    stop("No max_number_of_compound input have been provided!")
  }else if(max_number_of_compound<0){
    stop("max_number_of_compound must be equal or greater than 0!")
  }

  if(is.na(ncores)|is.null(ncores))
  {
    stop("ncores must be a number greater than 0!")
  }else if(ncores<1){
    stop("ncores must be equal or greater than 0!")
  }


  if(verbose)cat("\nPreparing sirius ...","\n")

  tmpDir<-createTmpDir("chemdistiller_")
  do.call(file.remove, list(list.files(tmpDir, full.names = TRUE,recursive = T)))
  zip::unzip(parameter_zip_files,junkpaths = T,exdir = tmpDir)
  all_params<-list.files(tmpDir,full.names = T)


  tmpDir2<-tmpDir
  outDir<-paste(tmpDir2,"chemdistiller_res",sep = "/")
  dir.create(outDir)
  library(doFuture)

  if(ncores>1)
  {
    if(verbose)cat("Running chemdistiller in parallel...","\n")
    cl <- parallel::makeCluster(ncores, type = "PSOCK")
    plan(future::cluster, workers = cl)
  }else{
    if(verbose)cat("Running chemdistiller sequencial ...","\n")
    plan(sequential)
  }

  if(!is.numeric(timeout))
  {
    stop("timeout must be numberic!")
  }else if(timeout<0){
    stop("timeout must be equal or greater than than 0!")
  }

  if(!is.numeric(chech_file_interval))
  {
    stop("chech_file_interval must be numberic!")
  }else if(chech_file_interval<0){
    stop("chech_file_interval must be equal or greater than than 0!")
  }
  if(timeout<=chech_file_interval)
  {
    stop("timeout must be greater than chech_file_interval!")
  }
  if(is.na(progress_bar) | is.null(progress_bar))
  {
    stop("progress_bar must be a logical value!")
  }
  if(!is.logical(progress_bar))
  {
    stop("progress_bar must be a logical value!")
  }
  #
  # if(!is.numeric(total_check_time))
  # {
  #   stop("total_check_time must be numberic!")
  # }else if(total_check_time<0){
  #   stop("total_check_time must be equal or greater than than 0!")
  # }


  results<-NA
  if(!is.na(results_folder))
  {
    dir.create(results_folder)
  }

  if(progress_bar==TRUE)
    p <- progressr::progressor(along =  all_params[1:50])
  library(future.apply)
  results<-  future_lapply(all_params[1:50],function(par_file) {
    command_sirius<-readLines(par_file)
    splitParams<-strsplit(command_sirius,split = " ",fixed = T)

    ppmIndex<-sapply(splitParams,FUN =  function(x){grep(x,pattern = "DatabaseSearchRelativeMassDeviation",fixed=T)})
    ppm<-as.numeric(strsplit(splitParams[[1]][[ppmIndex]],split = "=",fixed=T)[[1]][[2]])

    ppmms2Index<-sapply(splitParams,FUN =  function(x){grep(x,pattern = "FragmentPeakMatchRelativeMassDeviation",fixed=T)})
    ppm_ms2<-as.numeric(strsplit(splitParams[[1]][[ppmms2Index]],split = "=",fixed=T)[[1]][[2]])

    compound<-basename(par_file)
    parentmass<-as.numeric(strsplit(compound,split = "_",fixed = T)[[1]][3])

    ionizationIndex<-sapply(splitParams,FUN =  function(x){grep(x,pattern = "PrecursorIonType",fixed=T)})
    ionization<-as.character(strsplit(splitParams[[1]][[ionizationIndex]],split = "=",fixed=T)[[1]][[2]])

    collision<-""
    collisionIndex<-sapply(splitParams,FUN =  function(x){grep(x,pattern = "PeakListString",fixed=T)})
    collision<-as.character(strsplit(splitParams[[1]][[collisionIndex]],split = "=",fixed=T)[[1]][[2]])
    collision<-gsub(pattern = "_",replacement = " ",x = collision,fixed=T)
    collision<-gsub(pattern = ";",replacement = "\n",x = collision,fixed=T)



    toCSI<-paste(">compound ",compound,"\n",
                 ">parentmass ",parentmass,"\n",
                 ">ionization ",ionization,"\n",
                 ">AdductSettings.detectable ",ionization,"\n",
                 ">AdductSettings.fallback ",ionization,"\n",
                 ">MS1MassDeviation.allowedMassDeviation ",ppm," ppm","\n",
                 ">MS2MassDeviation.allowedMassDeviation ",ppm_ms2," ppm\n",
                 ">NumberOfCandidatesPerIon ",max_number_of_compound,"\n",
                 ">StructureSearchDB ",database,"\n",
                 ">collision\n",collision,"\n",sep = "")


    local_dir<-paste(outDir,basename(par_file),sep = "/")
    dir.create(local_dir)
    write(toCSI,paste(local_dir,"toCSI.ms",sep="/"))
    inpitToCSIFile<-paste(local_dir,"toCSI.ms",sep="/")
    sirius_folder<-paste(local_dir,"sirius",sep="/")
    dir.create(sirius_folder)
    outputMGF<-paste(sirius_folder,"/",compound,".mgf",sep = "")
    chemdistiller_in_folder<-paste(local_dir,"chemdistiller_in",sep="/")
    chemdistiller_out_folder<-paste(local_dir,"chemdistiller_out",sep="/")
    dir.create(chemdistiller_in_folder)

   toCSICommand<-paste(" -i ", inpitToCSIFile, " mgf-export "," --output ",outputMGF,sep="")


    out_sirius<-system2(conda_path, c(main_params,"sirius",
                                      (toCSICommand)),stdout =T ,wait = T,stderr = T,timeout = timeout)

    toChemdistillerCommand1<-paste(outputMGF," ",chemdistiller_in_folder,sep="")
    out_chemdistiller<-system2(conda_path, c(main_params,"mgf_convert",
                                             (toChemdistillerCommand1)),stdout =T ,wait = T,stderr = T,timeout = timeout)


    toChemdistillerCommand2<-paste(" -d ", database_file, " -s ",svm_model_path,
                                   " --databases ",database," -p 1 "," -m ",ppm," -r ",max_number_of_compound," ", chemdistiller_in_folder," ",chemdistiller_out_folder,sep="")

    out_chemdistiller<-system2(conda_path, c(main_params,"annotate_ch",
                                      (toChemdistillerCommand2)),stdout =T ,wait = T,stderr = T,timeout = timeout)

    required_output<-paste(chemdistiller_out_folder,"/","annotated_spectra.json",sep = "")
    data_res<-NA

    if(file.exists(required_output))
    {
      data_res_tmp<-jsonlite::read_json(required_output)

      data_res_hits<-do.call(plyr::rbind.fill,lapply(data_res_tmp[[1]]$peaks[[1]]$annotations[[1]]$mol_candidates,as.data.frame))
      data_res_adducts<-sapply(data_res_tmp[[1]]$peaks, function(x){
        sapply(x$annotations,function(y){rep(y$adduct,length(y$mol_candidates))})

      })

      data_res<-cbind(data_res_hits,adducts=data_res_adducts)

      if(is.null(data_res_hits)){
        data_res<-data.frame()
        data_res_hits<-data.frame()
      }
      if( nrow(data_res_hits)>0)
      {

        file_info<-strsplit(basename(par_file),split = "_",fixed = T)[[1]]
        data_res$parentRT<-file_info[2]
        data_res$parentMZ<-file_info[3]
        data_res$fileName<-paste(file_info[4:length(file_info)],collapse  = "_")
        if(!is.na(results_folder))
        {
          write.csv(data_res,paste(results_folder,basename(par_file),sep = "/"))
        }
      }
    }else{
      if(verbose)cat(out_chemdistiller)
    }
    if(progress_bar==TRUE)
      p(sprintf("processing=%s", par_file))
    data_res
  }
  )
  #future:::ClusterRegistry("stop")

  number_if_success<-sum(unlist(sapply(results,nrow))>0)
  if(length(number_if_success)>0)
  {
    return(do.call(plyr::rbind.fill,results[unlist(sapply(results,nrow))>0]))
  }else{
    return(NA)
  }

}
