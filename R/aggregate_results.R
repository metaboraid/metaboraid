#' Aggregate the partial results of a search engine
#'
#' Each search engine should ideally return a data.frame. However, it can be the case that the process has been terminated.
#' If the result folder is set, one can use this function to aggreate the partial results into a larger data.frame.
#'
#' @param inputMS2List A MS2 list generated by \code{\link{map_features}}
#' @param input_camera A CAMERA object (results of preprocessing using CAMERA)
#' @param precursorppm Precursor ppm mass deviation for database search
#' @param fragmentppm Fragment (MS2) ppm mass deviation for database search
#' @param fragmentabs Fragment (MS2) absolute mass deviation for database search
#' @param minPrecursorMass Minimum precursor mass to consider. Default 0
#' @param maxPrecursorMass Maximum precursor mass to consider NA=all. Default NA
#' @param minPeaks The minimum number of MS2 peaks that should be present for an ion to be consider
#' @param maxSpectra The maximum number of ions to write (mostly used for testing)
#' @param mode Ionization mode. Either pos or neg corresponding to positive and negative, respectively
#' @param adductRules What types of adducts to consider. Either primary or extended (see details). Default primary
#' @param outputDir Output directory to write individual ions
#' @param searchMultipleChargeAdducts Set to TRUE if you want to consider the selected adducts (primary or extended) for unmapped ions or ions without adduct information from CAMERA. Default TRUE
#' @param includeMapped Set to TRUE if you want to include mapped ions. Default TRUE
#' @param includeUnmapped Set to TRUE if you want to include unmapped ions. Default FALSE
#' @param verbose Show information about different stages of the processes. Default FALSE
#' @export
#' @examples
#' mapped_ms2s<-map_features(inputMS2s = c("data/Pilot_MS_Control_2_peakpicked.mzML","data/Pilot_MS_Pool_2_peakpicked.mzML"),input_camera = camera_results)
#'add_c<-map_addcuts(inputMS2List=mapped_ms2s,input_camera=camera_results,
#'                   precursorppm=10,
#'                   fragmentppm=20,fragmentabs=0.01,minPrecursorMass=NA,maxPrecursorMass=NA,
#'                   minPeaks=0,maxSpectra=NA,mode="pos",adductRules="primary",
#'                   outputDir="general_parameters_3",searchMultipleChargeAdducts=T,
#'                   includeMapped=T,includeUnmapped=F,verbose=T)
#'
#'
#' @return
#' A zip file containing the parameters needed for all the search engines. Each file inside the zip file includes all the set parameters and MS2 ions and estimated neutral mass and adduct information
#'
#' @details
#' MetaboRAID attempts to estimate the neutral mass of the molecules to decrease the search space of search engines.
#' The approach starts with mapping the MS2 parent mz and RT to the CAMERA features. We then search whether that specific feature has been annotated with adducts or isoptopes.
#' If so, the neutral mass will be estimated based on the adduct information.
#' However if there is no adduct information in CAMERA results for a particular ion, if searchMultipleChargeAdducts is set to TRUE, we generate all the selected ions based on adductRules:
#' primary: [M-H]-, [M-2H+Na]-, [M-2H+K]-, [M+Cl]-, [M+H]+, [M+Na]+, [M+K]+, [M+NH4]+
#' extended: We genrated up to three changes state for adduct information for each of them
#'
#' @import reticulate
#' @import zip
#' @import parallel
#' @import future
#' @import progressr
#' @import future.apply
#' @import plyr
#'

aggregate_results<-function(path="",pattern="txt",verbose=F){
  if(verbose)cat("Checking the path...","\n")
  if(is.na(path) | is.null(path))
  {
    stop("path is not defined!")
  }
  if(!dir.exists(path)){
    stop("We did not find the path!")
  }
  if(verbose)cat("Gathering the list of files ...","\n")
  list_of_files<-list.files(path = path,full.names = T,pattern = pattern)
  if(verbose)cat("validating the list of files ...","\n")
  if(any(sapply(strsplit(list_of_files,split = "_",fixed = T),length)<3))
    stop("There are some files in the folder that do not match the pattern!")

  if(verbose)cat("Aggregating the list of files ...","\n")
  data_aggregated<-c()
  for(par_file in list_of_files)
  {
    data_res<-read.csv(par_file)

    if(nrow(data_res)>0)
    {
      file_info<-strsplit(basename(par_file),split = "_",fixed = T)[[1]]
      data_res$parentRT<-file_info[2]
      data_res$parentMZ<-file_info[3]
      data_res$fileName<-paste(file_info[4:length(file_info)],collapse  = "_")
      data_aggregated<-plyr::rbind.fill(data_aggregated,data_res)
    }

  }
  if(verbose)cat(sprintf("A total of %d files have been processed! Number of IDs: %d",length(list_of_files),nrow(data_aggregated)))
  return(data_aggregated)
}
