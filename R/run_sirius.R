#' Perform identification using FINGER-ID
#'
#' This function allows you to perform identification using FINGER-ID/
#' Please note that you need to have FINGER-ID, e.g using \code{\link{install_tools}}
#'
#' We install CSI-FINGERID in metaboraid_package environment.
#' At this stage, CSI-FINGERID, Metfrag and Chemdistiller can be installed on Linux, IOS and Windows however, you should install CFM-ID yourself (\url{https://cfmid.wishartlab.com/})
#'
#'
#'
#' @param parameter_zip_files A zip file containing MS2 parameter generated by \code{\link{map_adducts}}
#' @param database Name of the database to use: One of all, chebi, kegg, bio, natural products, pubmed, hmdb, biocyc, hsdb, knapsack, biological, zinc bio, gnps, pubchem, mesh, and maconda!
#' @param number_of_compounds_for_ion Number of compounds to consider for building trees. Default 1
#' @param number_of_compounds Number of compounds to report for each ion. Default 10
#' @param use_heuristic The heuristic will be used to initially rank the formula candidates. Default TRUE
#' @param mz_to_use_heuristic_only Set minimum m/z to only use heuristic tree computation. Default 650
#' @param mz_to_use_heuristic Set minimum m/z to enable heuristic preprocessing. Default 300
#' @param ncores Number of cores to use for parallel processing. Default 1
#' @param progress_bar Whether to show progress bar or not. Default FALSE
#' @param verbose Show information about different stages of the processes. Default FALSE
#' @param conda Conda binary to use. Default auto
#' @param env conda environment used to run the process. Default metaboraid_package
#' @param results_folder a path to a folder where results for EACH ion will be returned
#' @param chech_file_interval not used
#' @param total_check_time not used
#' @param timeout The maximum number of seconds to wait for a single out to give a result. Default 600
#' @param timeout_tree the number of seconds to wait for tree computation 0= unlimited. Default 0
#' @param only_top Return only the top candidate. Default TRUE
#' @export
#' @examples
#'
#' library(CAMERA)
#' library(metaboraid)
#' # Read MS1 and MS2 files
#' ms1_files<-system.file("ms1data",c("X1_Rep1.mzML","X2_Rep1.mzML"),package = "metaboraid")
#' ms2_files<-system.file("ms2data",c("sample1.mzML","sample2.mzML"),package = "metaboraid")
#'
#' # mass trace detection
#' xs <- xcmsSet(ms1_files,method="centWave",ppm=30,peakwidth=c(5,10))
#'
#' # mass trace matching
#' xsg <- group(xs)
#'
#' # convert to CAMERA
#' xsa <- xsAnnotate(xsg)
#'
#' # Group mass traces
#' anF <- groupFWHM(xsa, perfwhm = 0.6)
#'
#' # Detect isotopes
#' anI <- findIsotopes(anF, mzabs = 0.01)
#'
#' # Group using correlation
#' anIC <- groupCorr(anI, cor_eic_th = 0.75)
#'
#' # Find adducts
#' anFA <- findAdducts(anIC, polarity="positive")
#'
#' # map features and MS2s
#' mapped_features<-map_features(inputMS2s = ms2_files,input_camera = anFA,ppm = 10,rt = 10)
#'
#' # Map adducts
#' mapped_adducts<-map_adducts(inputMS2List=mapped_features,input_camera=anFA,
#'                             precursorppm=10,
#'                             fragmentppm=20,fragmentabs=0.01,minPrecursorMass=NA,maxPrecursorMass=NA,
#'                             minPeaks=10,maxSpectra=10,mode="pos",adductRules="primary",
#'                             outputDir="general_parameters_4",searchMultipleChargeAdducts=T,
#'                             includeMapped=T,includeUnmapped=F,verbose=T)
#'
#' # Run the search
#'
#' run_sirius("parameter_files.zip",database = "all",ncores = 10,progress_bar = T,verbose = T,results_folder = "pp",chech_file_interval = 2,timeout = 600,conda = "auto")
#'
#' @return
#' A dataframe containing the identified ions. The dataframe contains search engine and database specific information but also tree important columns: parentMZ, parentRT, fileName which are used to trace the ions by the downstream processes.
#' @import reticulate
#' @import zip
#' @import parallel
#' @import future
#' @import progressr
#' @import future.apply
#'
run_sirius<-function(parameter_zip_files=NA,database=NA,local_database=NA,number_of_compounds_for_ion=1,number_of_compounds=10,
                     use_heuristic=T,mz_to_use_heuristic_only=650,mz_to_use_heuristic=300,
                     ncores=1,progress_bar=F,verbose=F,conda = "auto",env="metaboraid_package",results_folder=NA,
                      chech_file_interval=2,total_check_time=20,timeout=600,timeout_tree=0,only_top=TRUE){
  if(verbose)cat("\nChecking software ...","\n")
  check_if_conda_is_installed(pkg = env,conda=conda)
  check_out<-suppressWarnings(check_if_software_exist("sirius",conda=conda))
  if(length(check_out)==1 && check_out==1)
  {
    stop("We did not find sirius! Please try installing the tools first!")
  }

  conda_path<-reticulate::conda_binary(conda)

  main_params<-c("run","-n",env)
  if(verbose)cat("\nChecking database ...","\n")
  if(!database%in%c("all", "chebi", "kegg", "bio", "natural products", "pubmed", "hmdb", "biocyc", "hsdb", "knapsack", "biological"," zinc bio", "gnps", "pubchem", "mesh", "maconda"))
  {
    stop("The database must be one of all, chebi, kegg, bio, natural products, pubmed, hmdb, biocyc, hsdb, knapsack, biological, zinc bio, gnps, pubchem, mesh, and maconda!")
  }

  local_db<-""
  if(database=="LocalCSV")
  {
    if(is.na(local_database))stop("When use database=LocalCSV, you need to provide a path to a CSV dataset")
    if(!file.exists(local_database)){
      stop(sprintf("We did not find %s! Please check the path!",local_database))
    }

    tmp<-read.csv(local_database)
    data_Base_col_names<-c( "Identifier",  "MonoisotopicMass" ,"MolecularFormula" ,"SMILES"        ,   "InChI"         ,   "InChIKey1"     ,   "InChIKey2"    ,    "InChIKey3"    ,    "Name"         ,    "InChIKey" )
    if(!all(data_Base_col_names%in%colnames(tmp))){

      stop(sprintf("The following columns are missing from your database file: %s!",paste(data_Base_col_names[!data_Base_col_names%in%colnames(tmp)],collapse = ",")))
    }
    local_db<-paste("LocalDatabasePath=",local_database,sep = "")

  }

  if(is.na(parameter_zip_files) | is.null(parameter_zip_files))
  {
    stop("parameter_zip_files is missing!")
  }else{
    if(!file.exists(parameter_zip_files)){
      stop(sprintf("We could not find %s! Check parameter_zip_files!",parameter_zip_files))
    }
  }

  if(any(is.na(number_of_compounds_for_ion)) | any(is.null(number_of_compounds_for_ion)))
  {
    stop("No number_of_compounds input have been provided!")
  }else if(number_of_compounds_for_ion<1){
    stop("number_of_compounds_for_ion must be higher than 1!")
  }

  if(any(is.na(number_of_compounds)) | any(is.null(number_of_compounds)))
  {
    stop("No number_of_compounds input have been provided!")
  }else if(number_of_compounds<1){
    stop("number_of_compounds must be higher than 1!")
  }

  if(is.na(ncores)|is.null(ncores))
  {
    stop("ncores must be a number higher than 1!")
  }



  if(use_heuristic)
  {
    if((!is.numeric(mz_to_use_heuristic_only) & mz_to_use_heuristic_only<0))
    {
      stop("mz_to_use_heuristic_only must be numberic and higher than 0")
    }

    if((!is.numeric(mz_to_use_heuristic) & mz_to_use_heuristic<0))
    {
      stop("mz_to_use_heuristic must be numberic and higher than 0")
    }
  }



  if(verbose)cat("\nPreparing sirius ...","\n")

  tmpDir<-createTmpDir("sirius_")
  do.call(file.remove, list(list.files(tmpDir, full.names = TRUE,recursive = T)))
  zip::unzip(parameter_zip_files,junkpaths = T,exdir = tmpDir)
  all_params<-list.files(tmpDir,full.names = T)


  tmpDir2<-tmpDir
  outDir<-paste(tmpDir2,"sirius_res",sep = "/")
  dir.create(outDir)
  library(doFuture)

  if(ncores>1)
  {
    if(verbose)cat("Running sirius in parallel...","\n")
    cl <- parallel::makeCluster(ncores, type = "PSOCK")
    plan(future::cluster, workers = cl)
  }else{
    if(verbose)cat("Running sirius sequencial ...","\n")
    plan(sequential)
  }

  if(!is.numeric(timeout))
  {
    stop("timeout must be numberic!")
  }else if(timeout<0){
    stop("timeout must be equal or greater than than 0!")
  }

  if(!is.numeric(chech_file_interval))
  {
    stop("chech_file_interval must be numberic!")
  }else if(chech_file_interval<0){
    stop("chech_file_interval must be equal or greater than than 0!")
  }
  if(timeout<=chech_file_interval)
  {
    stop("timeout must be greater than chech_file_interval!")
  }
  if(is.na(progress_bar) | is.null(progress_bar))
  {
    stop("progress_bar must be a logical value!")
  }
  if(!is.logical(progress_bar))
  {
    stop("progress_bar must be a logical value!")
  }
  #
  # if(!is.numeric(total_check_time))
  # {
  #   stop("total_check_time must be numberic!")
  # }else if(total_check_time<0){
  #   stop("total_check_time must be equal or greater than than 0!")
  # }


  results<-NA
  if(!is.na(results_folder))
  {
    dir.create(results_folder)
  }

if(progress_bar==TRUE)
    p <- progressr::progressor(along =  all_params)

    library(future.apply)
    results<-  future_lapply(all_params,function(par_file) {



      command_sirius<-readLines(par_file)
      splitParams<-strsplit(command_sirius,split = " ",fixed = T)

      ppmIndex<-sapply(splitParams,FUN =  function(x){grep(x,pattern = "DatabaseSearchRelativeMassDeviation",fixed=T)})
      ppm<-as.numeric(strsplit(splitParams[[1]][[ppmIndex]],split = "=",fixed=T)[[1]][[2]])

      ppmms2Index<-sapply(splitParams,FUN =  function(x){grep(x,pattern = "FragmentPeakMatchRelativeMassDeviation",fixed=T)})
      ppm_ms2<-as.numeric(strsplit(splitParams[[1]][[ppmms2Index]],split = "=",fixed=T)[[1]][[2]])

      compound<-basename(par_file)
      parentmass<-as.numeric(strsplit(compound,split = "_",fixed = T)[[1]][3])

      ionizationIndex<-sapply(splitParams,FUN =  function(x){grep(x,pattern = "PrecursorIonType",fixed=T)})
      ionization<-as.character(strsplit(splitParams[[1]][[ionizationIndex]],split = "=",fixed=T)[[1]][[2]])

      collision<-""
      collisionIndex<-sapply(splitParams,FUN =  function(x){grep(x,pattern = "PeakListString",fixed=T)})
      collision<-as.character(strsplit(splitParams[[1]][[collisionIndex]],split = "=",fixed=T)[[1]][[2]])
      collision<-gsub(pattern = "_",replacement = " ",x = collision,fixed=T)
      collision<-gsub(pattern = ";",replacement = "\n",x = collision,fixed=T)



      toCSI<-paste(">compound ",compound,"\n",
                   ">parentmass ",parentmass,"\n",
                   ">ionization ",ionization,"\n",
                   ">AdductSettings.detectable ",ionization,"\n",
                   ">AdductSettings.fallback ",ionization,"\n",
                   ">MS1MassDeviation.allowedMassDeviation ",ppm," ppm","\n",
                   ">MS2MassDeviation.allowedMassDeviation ",ppm_ms2," ppm\n",
                   ">NumberOfCandidatesPerIon ",number_of_compounds_for_ion,"\n",
                   ">StructureSearchDB ",database,"\n",
                   ">Timeout.secondsPerInstance ",timeout,"\n",
                   ">Timeout.secondsPerTree ",timeout_tree,"\n\n",
                   ">collision\n",collision,"\n",sep = "")


      local_dir<-paste(outDir,basename(par_file),sep = "/")
      dir.create(local_dir)
      write(toCSI,paste(local_dir,"toCSI.ms",sep="/"))
      inpitToCSIFile<-paste(local_dir,"toCSI.ms",sep="/")
      sirius_folder<-paste(local_dir,"sirius",sep="/")

      if(use_heuristic)
      {



        toCSICommand<-paste(" -i ", inpitToCSIFile," --output ",sirius_folder, " --cores ",1, " config",
                            " --UseHeuristic.mzToUseHeuristicOnly ", mz_to_use_heuristic_only, " --UseHeuristic.mzToUseHeuristic ", mz_to_use_heuristic,
                            " formula"," -c ",number_of_compounds," fingerid", "",sep="")


      }else{

        toCSICommand<-paste(" -i ", inpitToCSIFile," --output ",sirius_folder, " --cores ",1, " config",

                            " formula"," -c ",number_of_compounds," fingerid", "",sep="")

      }





      out_sirius<-system2(conda_path, c(main_params,"sirius",
                                         (toCSICommand)),stdout =T ,wait = T,stderr = T,timeout = timeout)

     dir_list<-list.dirs(sirius_folder,
            recursive = F,full.names = T)
      
    if(sum(grepl(dir_list,pattern = "toCSI"))>1){
    stop("More than one CSI outputs! something went wrong!")
    }
    cid <- dir_list[grepl(dir_list,pattern = "toCSI")]
     
      if(only_top==FALSE)
        {
        required_output<-paste(cid,"/","structure_candidates.tsv",sep = "")
        }else{
        required_output<-paste(sirius_folder,"/","compound_identifications.tsv",sep = "")
        }
    
  
      data_res<-NA

      if(file.exists(required_output))
      {
        data_res<-read.table(required_output,header = T,sep = "\t",quote = "",check.names = F,stringsAsFactors = F,comment.char = "")

        if(nrow(data_res)>0)
        {

          file_info<-strsplit(basename(par_file),split = "_",fixed = T)[[1]]
          data_res$parentRT<-file_info[2]
          data_res$parentMZ<-file_info[3]
          data_res$fileName<-paste(file_info[4:length(file_info)],collapse  = "_")
          if(!is.na(results_folder))
          {
            write.csv(data_res,paste(results_folder,basename(par_file),sep = "/"))
          }
        }
      }else{
        if(verbose)cat(out_sirius)
      }
      if(progress_bar==TRUE)
      p(sprintf("processing=%s", par_file))
      data_res
    }
    )



  future:::ClusterRegistry("stop")

  number_if_success<-sum(unlist(sapply(results,nrow))>0)

  if(length(number_if_success)>0)
  {
    return(do.call(rbind,results[!is.na(results)]))
  }else{
    return(NA)
  }

}
